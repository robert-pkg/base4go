package main

import (
	"flag"
	"fmt"
	"os"
	"regexp"
)

var (
	// 匹配 message XxxReply {...}
	reMessage = regexp.MustCompile(`message\s+(\w+Reply)\s*\{([\s\S]*?)\}`)

	// 匹配字段： type name = num;
	reField = regexp.MustCompile(`\s*(\w+)\s+(\w+)\s*=\s*\d+;`)
)

// go run main.go ../../api/Greeter.proto
func main() {
	// 1. 定义 -o 参数
	outFile := flag.String("o", "", "output file")
	flag.Parse()

	// 2. 剩余参数就是输入文件
	if flag.NArg() < 1 {
		fmt.Fprintln(os.Stderr, "usage: respgen -o output.go input.proto")
		os.Exit(1)
	}

	input := flag.Arg(0)

	if len(os.Args) < 2 {
		fmt.Println("usage: respgen xxx.proto")
		os.Exit(1)
	}

	b, err := os.ReadFile(input)
	if err != nil {
		panic(err)
	}
	src := string(b)

	var out *os.File
	if *outFile == "" {
		// 默认输出到 stdout
		out = os.Stdout
	} else {
		out, err = os.Create(*outFile)
		if err != nil {
			fmt.Fprintln(os.Stderr, "create output:", err)
			os.Exit(1)
		}
		defer out.Close()
	}

	fmt.Fprintln(out, "// Code generated by respgen. DO NOT EDIT.")
	fmt.Fprintln(out, "package api")
	fmt.Fprintln(out)

	matches := reMessage.FindAllStringSubmatch(src, -1)
	for _, m := range matches {
		msgName := m[1]
		body := m[2]

		fields := reField.FindAllStringSubmatch(body, -1)

		var dataType string
		hasCode := false
		hasMsg := false

		for _, f := range fields {
			ftype := f[1]
			fname := f[2]

			if fname == "code" && ftype == "int32" {
				hasCode = true
			}
			if fname == "msg" && ftype == "string" {
				hasMsg = true
			}
			if fname == "data" {
				dataType = ftype
			}
		}

		if hasCode && hasMsg {
			fmt.Fprintf(out, "func (r *%s) SetCode(code int32) { r.Code = code }\n", msgName)
			fmt.Fprintf(out, "func (r *%s) SetMsg(msg string)  { r.Msg = msg }\n", msgName)
		}

		if dataType != "" {
			fmt.Fprintf(out, "func (r *%s) SetData(data *%s) { r.Data = data }\n\n", msgName, dataType)
		}
	}
}
